# 1288. 새로운 불면증 치료법

### 문제 내용

> 민석이는 불면증에 걸렸다. 그래서 잠이 안 올 때의 민간요법 중 하나인 양 세기를 하려고 한다.
>
> 민석이는 1번 양부터 순서대로 세는 것이 재미없을 것 같아서 N의 배수 번호인 양을 세기로 하였다.
>
> 즉, 첫 번째에는 N번 양을 세고, 두 번째에는 2N번 양, … , k번째에는 kN번 양을 센다.
>
> 이렇게 숫자를 세던 민석이에게 잠은 더 오지 않고 다음과 같은 궁금증이 생겼다.
>
> 이전에 셌던 번호들의 각 자리수에서 0에서 9까지의 모든 숫자를 보는 것은 최소 몇 번 양을 센 시점일까?
>
> 예를 들어 N = 1295이라고 하자.
>
> 첫 번째로 N = 1295번 양을 센다. 현재 본 숫자는 1, 2, 5, 9이다.
>
> 두 번째로 2N = 2590번 양을 센다. 현재 본 숫자는 0, 2, 5, 9이다.
>
> 현재까지 본 숫자는 0, 1, 2, 5, 9이다.
>
> 세 번째로 3N = 3885번 양을 센다. 현재 본 숫자는 3, 5, 8이다.
>
> 현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.
>
> 네 번째로 4N = 5180번 양을 센다. 현재 본 숫자는 0, 1, 5, 8이다.
>
> 현재까지 본 숫자는 0, 1, 2, 3, 5, 8, 9이다.
>
> 다섯 번째로 5N = 6475번 양을 센다. 현재 본 숫자는 4, 5, 6, 7이다.
>
> 현재까지 본 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9이다.
>
> 5N번 양을 세면 0에서 9까지 모든 숫자를 보게 되므로 민석이는 양 세기를 멈춘다.
>
> **[입력]**
>
> 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에는 N (1 ≤ N ≤ 106)이 주어진다.
>
> **[출력]**
>
> 각 테스트 케이스마다 ‘#x’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고,
>
> 최소 몇 번 양을 세었을 때 이전에 봤던 숫자들의 자릿수에서 0에서 9까지의 모든 숫자를 보게 되는지 출력한다.
>
> ( 민석이는 xN번 양을 세고 있다. )

| 입력                                   | 출력                                                    |
| -------------------------------------- | ------------------------------------------------------- |
| 5<br/>1<br/>2<br/>11<br/>1295<br/>1692 | \#1 10<br/>\#2 90<br/>\#3 110<br/>\#4 6475<br/>\#5 5076 |



### 문제 풀이

```python
T = int(input())
for i in range(T):
    print(f'#{i+1}', end=' ')
    
    # 첫 번째 양의 번호를 등록한다.
    sheep = int(input())
    
    # 어떤 숫자들이 나왔는지 담을 문자열 변수를 선언한다.
    # 중복되는 값을 제거한다면 더 적은 메모리만을 사용할 수 있을 것 같다.
    numbers = ''
    sheeps = 0
    
    # j = 0부터 9까지 반복
    for j in range(10):
        
        # j와 같은 숫자가 나올때까지 반복
        while str(j) not in numbers:
            
            # 현재 나온 숫자들을 numbers에 저장한다.
            sheeps += sheep
            numbers += str(sheeps)
            
    # 마지막 양의 번호를 출력한다.
    print(sheeps)
```

> 0 ~ 9까지 숫자가 있는지 판단하기 위해 많은 삽질을 했다.
>
> - __삽질 1__
>
> ```python
> while ('0' and '1' and '2' and ... '9') not in numbers:
>     sheeps += sheep
>     numbers += str(sheeps)
> ```
>
> > `and`는 결합법칙이 성립이 안되는 듯 하다. 입력값에 1을 넣으면 9에서 반복문이 멈추는 등 알 수 없는 이유로 의도한대로 나오지 않았다.
>
> - __삽질 1__
>
> ```python
> while '0' in numbers and '1' in numbers and ... '9' in numbers:
>     sheeps += sheep
>     numbers += str(sheeps)
> ```
>
> > 정상적으로 작동이 되었다. 그러나 너무 길고 거추장스러웠다. 이번 알고리즘 문제가 조건이 10개뿐이어서 망정이지 100개쯤 되면 못써먹을 방법이기 때문에 새로운 방법을 고안했다.
>
> - __최종본__
>
> ```python
> for j in range(10):
>     while str(j) not in numbers:
>         sheeps += sheep
>         numbers += str(sheeps)
> ```
>
> > 2중 반복문을 사용해 훨씬 깔끔해졌다. 더군다나 한번에 10개의 조건을 모두 찾는 방식이 아니라 0부터 순차적으로 찾아나가는 방식이기 때문에 실행속도도 훨씬 빠르다. 또한 조건이 훨씬 많이 주어지더라도 같은 방식으로 해결할 수 있다는 장점이 있다.
>
> - __한계__
>
> 현재 코드는 `numbers`라는 변수에 문자열을 한없이 추가한다. 그러다보니 `numbers`를 저장하는데 많은 데이터가 소모되고, 불러오는데 실행속도가 줄어들 우려가 있다. 이를 개선하기 위해 __중복 요소 제거__를 매번 해주면, 메모리와 실행속도 측면에서 이점이 있을 것이라고 생각된다.