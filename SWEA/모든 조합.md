# 모든 조합

## 재귀함수 이용

```python
def combine(test_list):
    
    # 조합들을 담을 list
    arr = []
    
    # 재귀함수 실행
    recursion([], test_list, arr)
    
    # 0번은 빈 리스트([])이므로 제외한다.
    return arr[1:]

# 재귀함수
def recursion(l1, l2, arr):
    
    # l1에 조합의 경우를 담아서 .append
    arr.append(l1)
    
    # 1. 재귀가 l2가 빈 리스트가 될 때까지 돌아간다. (그때까지 l1에 요소가 하나씩 추가.)
    # arr: [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]
    # 2. 이후 재귀가 돌아오면서 l1에는 한 단계 전으로 되돌아오고 i는 1씩 증가함.
    # arr: [...[1, 2, 3, 4], [1, 2, 4], [1, 3, 4], [1, 4], [2], ...]
    for i, x in enumerate(l2):
        recursion(l1 + [x], l2[i+1:], arr)
        
    # l1이 [4]가 되면 for문이 종료되며 arr 반환.
    return arr
```



## bit 연산 이용

```python
def combine(test_list):
    n = len(test_list)
    
    # 조합들을 담을 list
    results = []
    
    # test_list의 조합의 경우의 수를 2진으로 표현
    for i in range(1<<n):
        result = []
        
        # 2진으로 표현된 값에서 0이 아닌 값(0001, 0010, 0100, 1000 등)만 뽑아 조합을 만듦.
        # 예를 들어 배열이 [1, 2, 3, 4]이고, 2진이 (1010)이라면, [1, 3] 추출
        for j, pro in enumerate(test_list):
            if i & (1<<j) != 0:
                result.append(pro)
        results.append(result)
    return results[1:]
```

