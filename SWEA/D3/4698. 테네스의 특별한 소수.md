# 4698. 테네스의 특별한 소수

### 문제 내용

> 테네스는 소수를 좋아한다. 소수란 1과 자기 자신만으로 나뉘어 떨어지는 숫자로 작은 것부터 나열하면 2, 3, 5, 7, 11, 13, 17, 19, 23, …같은 수들이 있다.
>
> 또한 테네스는 D를 포함하는 숫자도 좋아한다. 그렇기에 소수가 D를 포함하면 더욱 더 좋아하여 특별한 소수라고 부르기로 했다.
>
> 예를 들어 D = 3이면 3, 13, 23, … 같은 소수들이 3을 포함하였으므로 테네스는 이런 숫자들을 특별한 소수라고 부를 것이다.
>
> D가 주어질 때, A이상 B이하의 수 중에서 특별한 소수인 것들의 개수를 구하는 프로그램을 작성하라.
>
> 
> **[입력]**
>
> 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
>
> 각 테스트 케이스의 첫 번째 줄에는 세 정수 D, A, B(1 ≤ D ≤ 9, 1 ≤ A ≤ B ≤ 106)가 공백으로 구분되어 주어진다.
>
> **[출력]**
>
> 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 특별한 소수의 개수를 출력한다.

| 입력                            | 출력               |
| ------------------------------- | ------------------ |
| 2<br />3 10 30<br />7 1 1000000 | #1 2<br />#2 43506 |



### 문제 풀이

- 에라토스테네스의 체를 이용한 소수 찾기 함수

```python
# n 이하의 소수를 모두 찾는 함수
def primes_up_to(n):
    
    # 2 이상의 모든 항에 대해 True. 소수가 아닌 것들을 False로 바꾸어 제외.
    seive = [False, False] + [True] * (n-1)
    
    # n**0.5 까지만 판별해도 됨.
    for k in range(2, int(n ** 0.5 + 1.5)):
        
        # == if 소수:
        if seive[k]:
            
            # 소수의 배수인 것들도 False.
            seive[k*2::k] = [False] * ((n - k) // k)
            
    # True인 행만 반환
    return [x for x in range(n+1) if seive[x]]
```

> 선정한 범위의 수 만큼 True로 돼있는(0, 1번 제외) list를 미리 만들어 둠으로서 계산시간을 획기적으로 단축한다.
>
> 소수를 순차적으로 판별하며 그 소수의 배수들을 False로 바꾼다.
>
> 그러면 순차적으로 판별이 되는 수들은 모두 소수이며, 결국 list에는 소수번째 번호만 True로 남게 된다.
> __위 code의 `if seive[k]` 문장에서 k들을 새로운 list에 바로 저장하면 더욱 최적화가 될 것 같다. (아닌가?) __
>
> 여기서 `n**0.2`까지만 계산하는 이유는 거기까지 하면 남은 수들은 모두 False이기 때문이다.



- 본문

```python
T = int(input())
for tc in range(1, T+1):
    d, a, b = map(int, input().split())

    primes = primes_up_to(b)
    count = 0
    for prime in primes:
        if prime >= a and str(d) in str(prime):
            count += 1
    print(f'#{tc}', count)
```

> 소수이면서, d를 포함하는 수들을 모아 간단하게 문제를 해결했다.