# 데이터 구조체

파이썬의 특징: 시퀀스를 단일하게 처리한다. (문자열, 리스트, 바이트 시퀀스 등이 반복, 슬라이싱, 정렬 등 공통된 연산을 적용할 수 있다는 뜻.)

파이썬에서 제공하는 다양한 시퀀스를 이해하면 코드를 새로 구현할 필요가 없고, 시퀀스 자료형을 적절히 지원하고 활용할 수 있게 API를 정의할 수 있다.



## 2.1 내장 시퀀스 개요

파이썬 표준 라이브러리는 __컨테이너 시퀀스__ 와 __균일 시퀀스__ 로 나눌 수 있다.

| 컨테이너 시퀀스                                            | 균일 시퀀스                                            |
| ---------------------------------------------------------- | ------------------------------------------------------ |
| 서로 다른 자료형의 항목을 담을 수 있다.                    | 단 하나의 자료형만 담을 수 있다.                       |
| 데이터가 직접 담겨있지 않고, 객체에 대한 참조를 담고 있다. | 자신의 메모리 공간에 각 항목의 값을 직접 담는다.       |
| 메모리를 많이 사용한다.                                    | 메모리를 더 적게 사용한다.                             |
| __list, tuple, collections.deque ...__                     | __str, bytes, bytearray, memoryview, array.array ...__ |

시퀀스를 선언하면, 메모리 공간에 시퀀스가 할당되며, 이 안에 데이터가 들어간다.

컨테이너 시퀀스의 경우 시퀀스 메모리 공간에 참조값(주소값(?))이 들어가고, 균일 시퀀스의 경우 데이터가 직접 들어간다.

컨테이너 시퀀스는 내부 데이터가 따로 선언이 되며 그 데이터를 가리키는 참조도 저장이 되어야 하므로 메모리를 많이 사용한다.

대신에 자료형이 다른 객체의 주소값들을 담는 방식으로 서로다른 자료형의 항목을 담을 수 있다.

[그럼 데이터가 직접 들어가는 상황에서는 왜 서로 다른 자료형을 담을 수 없을까? 데이터를 메모리에 저장할 때 타입이 따로 저장이 되는건가?]()



시퀀스는 내부 데이터를 변경할 수 있는지의 여부로 __가변 시퀀스__ 와 __불변 시퀀스__ 로 나눌 수도 있다.

시퀀스의 상속 구조를 이해하면 왜 가변과 불변으로 나뉘는지 알 수 있다.

우선 Sequence는 Container (메소드 \_\_contains\_\_), Iterable (메소드 \_\_iter\_\_), Sized (메소드 \_\_len\_\_)를 상속한다.

또한 MutableSequence는 Sequence를 상속한다. 그리고 \_\_setitem\_\_ , \_\_delitem\_\_ , insert 등의 메소드를 추가로 선언하여 가변적인 처리를 가능하게 만든 것이다.

- MutableSequence를 상속하는 것이 가변 시퀀스가 된다. (list, bytearray, array.array, collections.deque, memoryview ...)
- Sequence를 상속하는 것이 불변 시퀀스가 된다. (tuple, str, bytes ...)



## 2.2 지능형 리스트와 제너레이터 표현식

지능형 리스트와 제너레이터 표현식을 사용하면 장점:

- 가독성이 좋다
- 실행속도가 빠르다



### 2.2.1

지능형 리스트란 무엇인가?

```python
>>> symbols = '!@#$%'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[33, 64, 35, 36, 37]
```

다만 지능형 리스트를 잘못 사용하면 오히려 가독성이 떨어질 수도 있다.

가능하면 짧게, 명료하게 작성해야 한다. 그렇지 못하면 그냥 반복문을 사용하는게 낫다.

tip: 파이썬에서는 괄호 안에서의 개행이 무시된다. 따라서 괄호 안에서 개행을 할때는 역슬래시(\\)를 치지 않아도 된다.



지능형 리스트는 더 이상 메모리를 누수하지 않는다.

python3에서 달라진 점이다.

메모리를 누수하지 않는다는 뜻은 네임스페이스를 의미한다.

```python
>>> x = "ABC"
>>> dummy = [ord(x) for x in x]
>>> x
'ABC'
>>> dummy
[65, 66, 67]
```

dummy에서 사용한 x라는 변수는 dummy를 생성할때만 사용한다.



### 2.2.2 지능형 리스트와 map(), filter() 비교

map()과 filter() 로 구현할 수 있는 모든 작업은 지능형 리스트로도 대체가 가능하다!

```python
symbols = "!@#$%"

# map()/filter()
>>> beyond_ascii = list(filter(lambda symbol: symbol < 40, map(ord, symbols)))         
>>> beyond_ascii
[33, 35, 36, 37]

# 지능형 리스트
>>> beyond_ascii = [ord(symbol) for symbol in symbols if ord(symbol) < 40] 
>>> beyond_ascii                                                           
[33, 35, 36, 37]
beyond_ascii	# [33, 35, 36, 37]
```

지능형 리스트로 구현한 방법이 가독성이 더 좋다!

뿐만 아니라 속도도 더 빠르다고 한다!



### 2.2.3 데카르트 곱

지능형 리스트 안에서 반복문을 두번 돌려서 데카르트 곱을 구현할 수 있다.

다음은 사이즈가 3개, 색상이 2개인 티셔츠의 리스트를 만드는 예시이다.

```python
>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> tshirts = [(color, size) for color in colors 
               				 for size in sizes]
>>> tshirts
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('white', 'S'), ('white', 'M'), ('white', 'L')]
```



### 2.2.4 제너레이터 표현식

제너레이터 표현식은 지능형 리스트와 비슷하지만 대괄호 대신 소괄호를 사용한다.

리스트를 통째로 만들지 않고 iterator protocol을 이용해서 항목을 하나씩 생성해서 전달하는 특징이 있다. (메모리 사용이 적다.)

```python
>>> symbols = '!@#$%'
>>> tuple(ord(symbol) for symbol in symbols)
(33, 64, 35, 36, 37)
```

제너레이터가 동작하는 원리는 closer와 연관이 있는데,

closer로 데이터를 생성하는 객체를 선언하고, 그 closer 안에서 반복문을 돌고 yeild로 생성한 값을 반환한다.

그리고 또다시 closer를 호출하면 yeild 이후의 코드가 동작하면서 반복문을 또다시 돌고 다시 yeild로 값을 반환한다.

이렇게 필요할 때마다 데이터를 생성하여 반환을 하기 때문에 메모리 소모가 적다.



## 2.3 튜플은 단순한 불변 리스트가 아니다

tuple은 필드명이 없는 레코드로 사용할 수도 있다.

> 레코드란? 데이터베이스에서 하나의 단위로 취급되는 자료의 집합.
>
> DB 테이블에서 하나의 가로줄을 의미한다.

### 2.3.1 레코드로서의 튜플

레코드로 사용되는 튜플은 인자의 순서가 중요하므로 정렬을 하면 정보가 파괴됨을 주의

```python
>>> lax_coordinates = (33.9425, -118.408056)	# 로스앤젤레스 국제공항의 위도, 경도
>>> city, tear, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)	# 도쿄에 대한 데이터
>>> traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
>>> for passport in sorted(traveler_ids):
...     print('%s/%s' % passport)
... 
BRA/CE342567
ESP/XDA205856
USA/31195855
>>> for country, _ in traveler_ids:
...     print(country)
... 
USA
BRA
ESP
```

튜플이 레코드로 잘 작동하는 이유는 언패킹 메커니즘 덕분이다.

### 2.3.2 튜플 언패킹(반복형 언패킹)

언패킹이란 묶여있던 데이터를 낱개로 분할하는 것을 뜻한다.

```python
>>> lax_coordinates = (33.9425, -118.408056)
>>> latitude, longtude = lax_coordinates
>>> latitude
33.9425
>>> longtude
-118.408056
```

`,` 로 구분해서 여러개의 변수에 데이터를 한번에 받는다. 이를 이용해 임시변수 없이 두 값을 바꾸는 것도 가능하다.

```python
a, b = b, a
```

언패킹 시 데이터의 길이가 정해져있지 않을 때에는 `*` 를 사용한다.

```python
>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)

>>>def test(a, b, c):
...    pass
>>> test(*args)
```

### 2.3.3 내포된 튜플 언패킹

다른 튜플이 내포된 튜플 `(a, b, (c, d))` 는 다음과 같이 언패킹할 수 있다.

```python
>>> alphabet = ('a', 'b', ('c', 'd'))
>>> a, b, (c, d) = alphabet
>>> a
'a'
>>> b
'b'
>>> c
'c'
>>> d
'd'
```

### 2.3.4 명명된 튜플 (namedtuple)

collections.namedtuple()

- 튜플의 서브클래스를 생성하는 팩토리함수. (팩토리함수란? __객체__ 를 반환하는 함수)
- 디버깅 시 유리하다.

```python
>>> from collections import namedtuple
>>> City = namedtuple('City', 'name country population coordinates')
>>> tokyo = City('Tokey', 'JP', 36.933, (35.689722, 139.691667))
>>> tokyo
City(name='Tokey', country='JP', population=36.933, coordinates=(35.689722, 139.691667))
>>> tokyo.population
36.933
>>> tokyo.coordinates
(35.689722, 139.691667)
>>> tokyo[1]
'JP'
```

namedtuple은 _fields 속성, _make