# 파이썬 꿀팁

### Class

- class 안에 주석(`#` 말고 `""`)을 왜 달아야 할까?

  사실 달지 않아도 작동하는데는 상관이 없다.

  그러나 주석을 달아주면 협업할 때 또는 내가 쓴지 오래된 코드를 볼 때 큰 도움이 된다.

  

  해당 클래스가 어떤 일을 하는지 궁금할 때, \__doc__ 매직매서드를 사용해보자.

  그럼 바로 클래스 내부에 적어둔 주석이 출력되어 그 클래스를 설명해준다.

  ```python
  class Car():
      """이 함수에 달려있는 주석1"""
      """이 함수에 달려있는 주석2"""
      def __init__(self):
          ...
  ```

  그럼 위 처럼 클래스 안에 주석이 두개 달려있으면 어떻게 출력될까?

  ```python
  print(Car.__doc__)
  
  >> 이 함수에 달려있는 주석1
  ```

  첫번째 주석은 출력되고, 두번때 주석은 출력되지 않는다. (그러니 한개만 달자 ㅎㅎ)

  

  아참! 파이썬에서 가장 유명한 자동문서화 라이브러리도 이 주석을 활용한다.

  바로 `sphinx`!

  양식은 아래와 같다.

  ```python
  class Car():
      """이 클래스는 요래요래 한 클래스 입니다.
      
      :param int price: 자동차의 가격입니다.
      :param str color: 자동차의 색깔입니다.
      """
      
      def __init__(self, price, color):
          self.price = price
          self.color = color
      
      def set_color(self, color):
          """이 자동차의 색깔을 변경합니다.
          
          :param str color: 변경할 색깔입니다.
          :returns bool: True or False
          """
  ```

  이렇게 적으면 스핑크스가 자동으로 문서로 만들어준다!

  

  스핑크스까진 쓰지 않더라도 문서화를 통해 더 실력있는 개발자가 되자!

  

- 인스턴스 앞에 언더바(`_`)를 붙이자!

  이것도 안붙여도 작동하는데는 상관이 없다.

  그러나 언더바를 붙였을 때 장점이 있다.

  파이썬 고수들은 `dir`과 `__dict__`를 잘 활용한다. 아래와 같은 클래스에 `dir`을 사용한 결과를 보자.

  ```python
  class Car():
      
      car_cnt = 0
      
      def __init__(self, price, color):
          self._price = price
          self._color = color
  		Car.car_cnt += 1
      
      def detail_info(self):
          ...
  
  ferrari = Car(500, 'red')
  print(dir(ferrari))
  ```

  ```
  ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_color', '_price', 'car_cnt', 'detail_info']
  ```

  잘 보면 `__class__`같이 앞뒤로 언더바가 두개씩 붙어있는건 매직매서드라는 것을 알 수 있다.

  그리고 인스턴스들은 앞에 언더바 하나를 붙인 것들이다. (내가 그렇게 썼으니까 ㅋㅋ)

  또한 클래스변수인 `car_cnt`와 메서드인 `detail_info`는 앞뒤로 언더바가 붙어있지 않다.

  

  이를 통해 다른 개발자들은 `dir`을 찍어보고, 언더바로 시작하는건 인스턴스라는 것을 알 수 있다.

  또한, 언더바가 없는 것들은 클래스가 공통으로 소유하고 있는 것들임을 알 수 있다.

  협업을 중요시 한다면 이러한 사소한 배려는 큰 도움이 될 것이다! (꼭 지켜야하는건 아님 ㅎㅎ)

  

- 클래스변수를 잘 활용하자!

  예전에 공부해놓고 당최 쓰질 않아서 까먹었던 것.

  ```python
  class Car():
      
      car_cnt = 0
      
      def __init__(self, price, color):
          self._price = price
          self._color = color
  		Car.car_cnt += 1
      
      def __del__(self):
          Car.car_cnt -= 1
  
  print(Car.car_cnt)
  ferrari = Car(500, 'red')
  print(Car.car_cnt)
  del ferrari
  print(Car.car_cnt)
  ```

  

  ```
  0
  1
  0
  ```

  클래스변수란 위 예제의 `car_cnt`이다.

  `__init__`에 Car.car_cnt를 1씩 증가시킨다면, 자동차를 선언할때마다 car_cnt가 1씩 증가하게 된다.

  마찬가지로, `__del__`에 car_cnt를 1씩 감소시킨다면, 선언한 자동차를 삭제할 때 마다 car_cnt가 1씩 감소하게 된다.

  이렇게 해당 클래스의 객체 수를 확인하는데 대표적으로 사용된다. (더 다양한 방법으로 활용할 수 있다.)

  

  위에서는 `Car.car_cnt`를 출력했지만,

  ```python
  print(ferrari.car_cnt)
  ```

  를 출력해도 __같은 결과__가 나타난다. ferrari에서 car_cnt 인스턴스를 찾다가 없으면 Car에서 car_cnt를 찾기 때문!

  그럼 만약 같은 이름의 `car_cnt`가 인스턴스로도 있다면 어떨까?

  ```python
  class Car():
      
      car_cnt = 0
      
      def __init__(self, price, color):
          self._price = price
          self._color = color
          self.car_cnt = 100
  
  
  ferrari = Car(500, 'red')
  print(ferrari.car_cnt)
  print(Car.car_cnt)
  ```

  ```
  100
  0
  ```

  ferrari에서는 100이 출력되고, Car에서는 0이 출력된다.

  앞서 말했듯, ferrari에서 car_cnt를 찾을때는 먼저 ferrari에 car_cnt 인스턴스를 찾고, 없다면 그 상위단(Car)에 있는지 확인한다.

  만약 `self.car_cnt = 100` 이라는 코드가 없다면 `0`이 출력되었을 것이다.
  
  
  
- 처음 사용하는 클래스 또는 함수는 `__doc__`, `__dict__`, `dir()`을 활용하자.

  `__doc__`는 해당 클래스(또는 메서드) 작성자가 작성한 설명서를 출력한다.

  `dir()`는 해당 클래스가 가지고 있는 모든 메서드를 리스트 형태로 출력한다.

  `__dict__`는 `dir()`과 비슷한데, 딕셔너리 형태로 출력한다는 점이 다르고, 선언하지 않은 기본적인 매직메서드`__eq__, __ge__, __new__, __repr__` 등은 출력하지 않는다.

  

- 패킹(`*`)을 활용하자!

  ```python
  a, b, c = 1, 2, 3, 4, 5
  ```

  위 식을 쓰면 당연히 에러가 난다. 그러나!

  ```python
  a, b, *c = 1, 2, 3, 4, 5
  ```

  위 식은 에러가 나지 않는다! 이를 출력해보면,

  ```python
  print(a, b, c)
  
  >>> 1 2 [3, 4, 5]
  ```

  이게 바로 __패킹__이다.

  마찬가지로 함수의 arg로도 담을 수 있다.

  ```python
  class Car:
      def __init__(self, a, b, *c):
          self.a = a
          self.b = b
          self.c = c
  
  car = Car(1, 2, 3, 4, 5)
  print(car.a)
  print(car.b)
  print(car.c)
  ```

  위 코드를 출력하면 아래와 같이 나타난다.

  ```python]
  1
  2
  (3, 4, 5)
  ```

  그런데 위에서 패킹을 썼을때는 __list__ 형태로 나오더니, 지금은 __tuple__ 형태로 출력된다?? 띠용...

  class의 변수로 들어왔을 때는 내부에서 변경할 수 없도록 설정한 것인데;; 왜 그런건지는 나중에 알아봐야겠다.






### dictionary

- `setdefault`를 적극 활용하자!

  파이썬에서 `dictionary`에 원소를 추가하는 방법에는 여러가지가 있다.

  ```python
  test1, test2, test3 = {}, {}, {}
  
  test1['key'] = 'value'
  test2['key'] = test2.get('key', 'value')
  test3.setdefault('key', 'value')
  ```

  ```python
  test1
  >> {'key': 'value'}
  
  test2
  >> {'key': 'value'}
  
  test3
  >> {'key': 'value'}
  ```

  test1 (`test1['key'] = 'value'`)의 경우, 간단히 dictionary에 값을 추가할 수 있지만, 기존에 있던 값을 유지하는 속성은 없다.

  호출될때마다 기존 값에 새로운 원소를 추가하는 함수를 생각해보자.

  ```python
  try:
      test1['key'] = test1['key'] + ['a']
  except:
      test1['key'] = []
  ```

  첫 번째 방법을 사용하니 코드가 길어진다. if문 또는 try문을 사용할 수 밖에 없다.

  ```python
  test2['key'] = test2.get('key', []) + ['a']
  ```

  `get`을 사용한 방식이다. 코드가 한줄로 간단해졌다. 아까보다 훨씬 낫다.

  ```python
  test3.setdefault('key', []).append('a')
  ```

  `setdefault`를 이용한 방식이다.

  코드가 더 짧아질 뿐만 아니라 시간도 빨라졌다. (`get`방식의 약 80%의 속도)

  

  위 세 가지 방식 모두 상황에 맞는 때가 있다. 파이썬을 잘 하는 사람은 이것들을 적재적소에 잘 사용하는 사람일 것이다.
  
- set의 정의방식:

  set을 정의하는 방식에는 다음과 같은 방식이 있다.

  ```python
  s = set([1])
  s = {1}
  ```

  이 중에 어떤 방식이 더 효율적일까??

  딱 봐도 1번이 비효율적일거 같긴 하다. 그러나 한번 증명을 해보자.

  ```python
  from dis import dis
  
  print(dis('set([1])'))
  print(dis('{1}'))
  ```

  ```
    1           0 LOAD_NAME                0 (set)
                2 LOAD_CONST               0 (1)
                4 BUILD_LIST               1
                6 CALL_FUNCTION            1
                8 RETURN_VALUE
                
    1           0 LOAD_CONST               0 (1)
                2 BUILD_SET                1
                4 RETURN_VALUE
  ```

  set([1]) 방식은 list를 만들고 그걸 set안에 넣어서 반환한다.

  {1} 방식은 set을 만들고 반환한다.

  예상했던대로 {1} 방식이 더 효율적이다.

  

### 일급함수(일급객체)

일급함수란, 변수처럼사용될 수 있는 함수를 뜻한다.

- 함수에서 리턴값에 호출 가능

  ```python
  def func():
      return func()
  ```

- 함수의 변수로 이용 가능

  ```python
  func1(func2())
  ```

- 함수를 변수에 저장 가능

  ```python
  var = func()
  ```

파이썬에서의 모든 함수는 요 일급함수이다.



- 요 일급함수를 이용한 파이썬의 특정 함수들을 알아보자!

  - map, filter

    map은 평소에 자주 사용하던거니까 패쓰

    filter는 알긴 아는데 써본적이 별로 없다. 좀더 자세히 기록해보자.

    ```python
    print(list(filter(lambda x: x < 5, [1, 3, 5, 7, 9])))
    ```

    ```python
    >> [1, 3]
    ```

    `filter(조건, 대상)` : 대상 안에서 조건에 맞는 원소들만 모아서 반환한다.

  - reduce

    한번도 써본적이 없는데 유용하게 사용될 때가 있다고 한다.

    ```python
    from functools import reduce
    
    print(reduce(print, [1, 3, 5, 7, 9]))
    ```

    ```python
    >> 1 3
    None 5
    None 7
    None 9
    None
    ```

    `reduce(함수, 대상)`: 대상의 첫번째, 두번째 원소를 함수에 넣어 실행하고, 그 반환값을 첫번째 위치에 다시 넣는다. 이를 끝까지 반복한다.

    좀 복잡하게 들릴 수 있는데, 위의 예제에서 살펴보면

    ```python
    print(1, 3)    # == None
    print(None, 5) # == print(print(1, 3), 5)
    print(None, 7) # == print(print(None, 5), 7)
    print(None, 9) # == print(print(None, 7), 9)
    print(None)    # == print(print(None, 9))
    ```

    이 순서로 진행된다.

  - partial

    만약 특정 함수를 반복해서 사용해야되는데, 그 원소 중 일부를 고정해놓고 싶다! 그럴 때 사용하는 함수이다.

    ```python
    from funtools import partial
    from operator import mul
    
    two = partial(mul, 2)
    print(two(5)) # 10
    ```

    여기서 two 함수는 *2와 같다.

    그럼 이건 어떨까?

    ```python
    two = partial(mul, 2)
    three = partial(two, 3)
    
    print(three())
    print(three(1))
    ```

    ```python
    >> 6
    >> Error
    ```

    print(three())를 하면, two(3)이 반환되고, 이를 mul(2, 3) == 6이 된다.

    반면 print(three(1))을 하면, two(1, 3)이 반환되고, 이는 mul(1, 3, 2)가 되므로 에러가 난다.

  - 익명함수(lambda함수)

    이것도 평소에 많이 쓰는거니 패쓰

    

  - 추가로 `함수형 프로그래밍` 이라는걸 공부하면 도움이 된다고 한다. 함 해보자.