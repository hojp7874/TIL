# 파이썬 필수 문법

## Copy

__Shallow Copy vs Deep Copy__

Shallow Copy

```python
a = [1, 2, 3]
b = a
```

위 예시에서의 `b = a` 가 바로 shallow copy(얕은 복사)이다.

```python
print(id(a) == id(b)) #==> True

a[1] = 5
print(b) #==> [1, 5, 3]
```

a와 b의 id값이 같으며 a의 값을 수정하면 b의 값도 바뀐다.

이는 a와 b가 동일한 객체를 참조하고 있기 때문이다.



__copy lib__

파이썬에서는 copy라는 라이브러리를 사용할 수 있다.

```python
from copy import copy, deepcopy

a = [1, 2, 3, [4, 5]]
b = copy(a)
c = deepcopy(a)
```

위 예시처럼 사용할 수 있다.

여기서 id값을 살펴보자

```python
print(id(a) == id(b)) #==> False
print(id(a) == id(c)) #==> False
```

둘 다 id값은 원조와 다르다.

하지만 리스트 안의 리스트에서는 차이가 난다.

```python
print(id(a[3]) == id(b[3])) #==> True
print(id(a[3]) == id(c[3])) #==> False
```

그냥 `copy`에서는 내부 요소까지 깊은복사를 하지는 못한다.



## Context Manager

> 당신은 python을 이용해 어떤 파일들을 수정하고 싶다.
>
> 그런데 파일이 너무 커서 동시에 3개가 켜지면 컴퓨터가 다운된다.
>
> 심지어 코드 수정중에 에러도 자주 발생한다.
>
> 그래서 context manager를 이용하려고 한다.

Context manager란 다루고자 하는 객체의 context(문맥)을 효율적으로 관리하는 작업이다.

File 객체의 경우, open과 close 두 개의 context를 가지고 있다.

```python
f = open('test.txt', 'r') #=> open
content = f.read()
f.close() #=> close
```

위의 일련의 과정이 context이다.

만약 중간에 에러가 발생하여 `close`가 안되면, 리소스를 계속 사용하기 때문에 `resource leak`이 발생한다.

그래서 예외처리를 해주면,

```python
f = open('test.txt', 'r') #=> open
try:
	content = f.read()
finally:
	f.close() #=> close
```

위 코드는 파이썬의 `with`를 이용해 간단하게 작성할 수 있다.

```python
with open('test.txt', 'r') as f:
    content = f.read()
```



매직 메서드 `__enter__` 와 `__exit__`가 있는데,

`f`에 `__enter__()`의 반환값이 할당되고,

with문을 빠져나올 때 `__exit__()`메서드가 호출된다.



다음은 context manageable한 클래스 예시이다.

```python
class FileContextManager:
    def __init__(self, file_name, method):
        print('__init__')
        self.file_obj = open(file_name, method)
        
    def __enter__(self):
        print('__enter__')
        return self.file_obj
    
    def __exit__(self):
        print('__exit__')
        self.file_obj.close()

print('작업 전')
with FileContextManager('test.txt', 'r') as f:
    content = f.read()
    print('작업 중...')

print('작업 끝!')
```

```
작업 전
__init__
__enter__
작업중...
__exit__
작업 끝!
```



## Under Score

파이썬에서는 underscore를 통해 변수의 특징을 표현하기도 한다.

#### 값을 무시하는 용도

```python
for _ in range(10):
    pass
```

위 코드는 for문을 10번 반복하지만, 그 값은 사용하지 않겠다는 의미다.

#### 접근지정자

```python
class Test:
    def __init__(self, a, b, c):
        self.a = a
        self._b = b
        self.__c = c
```

위 클래스의 인스턴스들은 언더스코어의 차이가 있다.

언더스코어가 없는 경우(a)는 마음껏 접근할 수 있는(public) 인스턴스이다.

언더스코어가 하나 있는 경우(b)는 접근은 가능하지만 가급적 보호해야하는(protected) 인스턴스이다.

언더스코어가 두 개 있는 경우(c)는 접근하지 않는 것이 권장되는(private) 인스턴스이다.

여기서 private라고 썼는데, 사실 파이썬에서는 강제로 접근할 수 없게 만들지는 못한다.

```python
print(dir(Test))
```

dir을 출력해보면, `a`와 `_b`는 있는데 `__c`가 없다. 대신 `_Test__c`가 있다. 언더스코어 두 개는 인스턴스명이 이렇게 바뀌어 저장된다.



#### getter, setter, @property

접근이 제한된 변수에 접근하기 위한 매우 파이써닉 한 방식이 있다.

```python
class Test:
    def __init__(self):
        self.__a = 'a'
       
    @property
    def a(self):
        print("'getter'")
        return self.__a
       
    @a.setter
    def a(self, value):
        print("'setter'")
        self.__a = value
       
    @a.deleter
    def a(self):
        print("'deleter'")
        del self.__a
```

```python
a = Test()
print(dir(a)) #=> ['_Test__a', ..., 'a']
```

보통 이렇게 인스턴스 이름과 똑같이 짓는게 국룰인 것 같다. (여러 블로그나 강의에서도 이름을 똑같이 지음.)

위 코드에서 getter, setter, deleter를 호출하는 방법은 다음과 같다.

```python
a = Test()

a.a			#=> 'getter'
a.a = 'b'	#=> 'setter'
del a.a		#=> 'deleter'
```

당연히 getter를 출력`print(a.a)`하면, `a._Test__a`가 출력된다.

이 property의 장점은, oop(객체지향)의 캡슐화를 견고하게 해주는 역할을 한다.

우선 캡슐화란, 어떤 객체를 함부로 조작할 수 없도록 만드는 것이다.

객체 안에는 여러 인스턴스들이 있는데 이것들을 직접 건드리게되면 오류 또는 문제가 생길 수 있다.

그래서 인스턴스는 감춰두고(캡슐처럼) 딱 정해진 기능만 수행할 수 있도록 만드는 것이다.

> 시계를 생각해보자.
>
> 우리는 시계의 시간을 볼 수 있고, 또 시간을 조절할 수 있다. 그러나 시계 내부의 톱니바퀴를 거드릴 수는 없다.
>
> 만약 톱니바퀴를 건드리게 되면 전문가가 아닌 이상 그 시계는 고장날 것이다.

property는 `__a` 인스턴스는 감춰두고, 메서드 a를 이용해 이를 관리할 수 있도록 만든다.

`get_a`와 `set_a` 메서드로 만들 수도 있지만 그러면 메서드가 많아져서 관리가 불편해진다.(또 골칫거리인 변수 네이밍도 필요가 없으니 얼마나 좋은가!)



## Overriding & Overloading

#### Overriding

> `자전거`라는 클래스에 바퀴가 2개로 정의되어있다.
>
> 당신은 `세발자전거` 클래스를 만들려고 하는데, `자전거` 클래스를 상속`Inheritance`하려고 보니까 바퀴 수가 맞지 않는다.
>
> 상속을 안하려니 모든 클래스변수와 메서드를 다시 정의해야해서 귀찮고, 그렇다고 자전거 클래스의 바퀴 수를 바꿀 수도 없는 노릇이다.
>
> 그래서 `Overriding`을 사용하려고 한다.

`Overriding`은 상속받은 내용에서 일부를 재정의하고 싶을 때 사용한다.

```python
class Bicycle():
    wheel = 2
    sit = 1
    handle = 2
   
class ThreeBicycle(Bicycle):
    wheel = 3
```



#### Overloading

> 한 클래스 내에 여러 개의 동일한 이름의 메서드를 정의하는 것.
>
> overriding은 부모와 같은 메서드를 정의하는 것이라면, overloading은 자기자신의 메서드와 같은 이름의 메서드를 정의하는 것이다.

변수가 하나 주어질 때, 두 개 주어질 때를 다르게  하기 위해 아래와 같은 방법을 사용한다고 가정해보자.

```python
class Sample():
    def add(self, x):
        return x
    
    def add(self, x, y):
        return (x, y)
```

될까? 당근 안된다. 뒤에 선언한 메서드가 앞에 선언한 메서드를 덮어써버리기 때문이다.

그렇기 때문에 일반적인 사람들은 분기를 만들 때 `if문`을 사용한다.

만약 자료형에 따른 분기를 만들고 싶다면 아래와 같이 하면 된다.

```python
class Sample():
    def add(self, x, y):
        if type(x) == 'int' and type(y) == 'int':
            return x + y
       	elif type(x) == 'str' and type(y) == 'str':
            return ','.join([x, y])
```

직관적이지도 않고 복잡해지면 분기를 나누는 것도 쉽지 않다. 더욱 파이써닉한 코드를 원한다면!?

`add`라는 이름의 메서드를 여러개로 나눠 `overloading`하는 방법도 생각해볼 수 있겠다.

그리고 이때 사용하기 좋은게 바로 `@dispatch`이다.

```python
from multipledispatch import dispatch

class Sample():
    @dispatch(int, int)
    def add(x, y):
        return x * y
    
    @dispatch(int, int, int)
    def add(x, y, z):
        return x * y * z
    
    @dispatch(float, float, float)
    def add(x, y, z):
        return x * y * z
```



## Meta Class

