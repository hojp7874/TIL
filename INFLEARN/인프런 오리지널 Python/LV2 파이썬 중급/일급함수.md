# 일급함수

## 클로저

### 변수의 scope

```python
c = 10
def func():
    print(c)
    c = 20

func()
```

```
UnboundLocalError: local variable 'c' referenced before assignment
```

단순히 생각했을때는 이미 글로벌에 c=10이 정의되어있기 때문에 `10`이 출력되어야 할 것 같은데, 에러가 난다.

함수 내부에 local c가 정의되어있다면, global c는 참조하지 않기 때문에 발생하는 현상이다.



```python
def closure():
    series = []
    def averager(v):
        series.append(v)
        print(f"inner >> {series} / {len(series)}")
        return sum(series) / len(series)
    return averager

avg_closure = closure()

print(avg_closure(10))
print(avg_closure(30))
print(avg_closure(50))
```

```
inner >> [10] / 1
10.0
inner >> [10, 30] / 2    
20.0
inner >> [10, 30, 50] / 3
30.0
```

단순히 생각하기로는 closure 함수가 return이 될 때 그 내부 변수인 `series`는 사라져야 정상라고 할 수 있다.

그런데 좀 더 자세히 들여다 보면 답이 나온다.

그렇다. 이 예제에서 `closure` 함수는 딱 한번 실행되었다.

```python
avg_closure = closure() # closure1는 이 때 한번만 실행된다.
```

실제로 closure 함수를 실행하기 위해서는 다음과 같이 해야한다.

```python
print(closure()(10))
```

그리고 이것은 closure1를 새롭게 선언한 것이기 때문에 내부변수가 초기화된다.

```
inner >> [10] / 1
10.0
```



Closure는 파이썬이 일급함수인 특성을 극단으로 이용한 방식이다.

그래서 잘 사용하면 멀티프로세싱을 할 때 도움이 될 수 있다.



클로저의 내부 함수에서 아우터 함수의 변수를 사용할 때는 `nonlocal` 이라는 선언방식을 사용해야 한다.

그 사용법은 다음과 같다.

```python
def closure():
    cnt = 0
    total = 0
    def avg(v):
        nonlocal cnt, total
        cnt += 1
        total += v
        return total / cnt
    return avg

avg_closure = closure()
print(avg_closure(15))
print(avg_closure(35))
print(avg_closure(40))
```

global을 사용하면 에러가 난다.



## 데코레이터

```
# 장점
# 중복제거, 코드간결, 공통함수 작성
# 로깅, 프레임워크, 유효성 체크..... -> 공통 기능으로 사용 가능
# 조합해서 사용 용이

# 단점
# 가독성 감소 (코딩하는거에 따라 다름)
# 특정 기능에 한정된 함수는 단일 함수로 작성하는게 유리.
# 디버깅 힘듦
```

데코레이터는 클로저에서 한번 더 업그레이드 한 개념이다.

예시는 아래와 같다.

```python
import time

def perf_clock(func):
    def perf_clocked(*args):
        st = time.perf_counter()
        result = func(*args)
        et = time.perf_counter() - st
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print("[%0.5fs] %s(%s) -> %r" % (et, name, arg_str, result))
        return result
    return perf_clocked

@perf_clock
def time_func(seconds):
    time.sleep(seconds)

@perf_clock
def sum_func(*numbers):
    return sum(numbers)

print(time_func(3))
print(sum_func(1, 2, 3, 4, 5))
```

이 데코레이터는 해당 함수의 시간이 얼마나 걸리는지 출력해주는 기능이다.

```python
@perf_clock
def time_func(seconds):
    time.sleep(seconds)
```

이렇게 time_func 위에 데코레이터를 씌우면

```python
time_func = perf_clock(time_func)
```

이것과 똑같다.

따라서 time_func 안에 seconds를 넣으면, perf_clocked(seconds)와 같아지는 것이다. (엄밀히 말하면 조금 다르긴 하다)

```python
time_func(seconds) = perf_clock(time_func)(seconds) = perf_clocked(seconds)
```

단 time_func과 perf_clocked의 차이점은 클로저 안에 내부변수의 차이이고 perf_clock 함수를 계속 호출하느냐 안하느냐의 차이이다.

